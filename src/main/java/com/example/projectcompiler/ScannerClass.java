package com.example.projectcompiler;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class ScannerClass {
    //Storing the operators ,relational operators ,symbols in list of string
    List<String> operators= List.of(new String[]{"+", "-", "*", "/"});
    List<String> relationalOperators1= List.of(new String[]{"=", "<", ">"});
    List<String> relationalOperators2=List.of(new String[]{"|=","<=",">=",":="});
    List<String> symbols=List.of(new String[]{":",";",",",")","(","."});
    public List<String> tokens(String input){
        //taking the input and starting split it in tokens
        List<String> tokens = new ArrayList<>();
        String fullToken="";
        for(int i=0;i<input.length();++i){
           char characterToBeChecked=input.charAt(i);
           //as the rules name is generated by the regular expression:letter ( letter | digit )*
            //here it will take the char if it is letter then it will be added to the fulltoken

            if( Character.isLetter(characterToBeChecked)){
                if(!fullToken.isEmpty() && Character.isDigit(fullToken.charAt(0)) ){
                    tokens.add(fullToken);
                    fullToken = "";
                }
                fullToken=fullToken+characterToBeChecked;
      //else if the current char is digit and the first char in full token is letter then it will be added to token in order to follow
                //the name rule like for example if the full token already contain num from the previous chars and the current char is digit 2 then
                //this condition make sure to add it to be num2
            }else if(Character.isDigit(characterToBeChecked) && !fullToken.isEmpty()&& Character.isLetter(fullToken.charAt(0))){
                fullToken=fullToken+characterToBeChecked;

            }
            //this condition to add float number in one token like if the previous char is 2 and the current is . it will check it by the following condition
            //to make sure to add them in one token according to real-value  which  generated by the regular expression: digit ( digit )*. digit ( digit )*

            else if (Character.isDigit(characterToBeChecked) || ( i-1>0 &&Character.isDigit(input.charAt(i-1))&& characterToBeChecked=='.' && i+1<input.length() && Character.isDigit(input.charAt(i+1)))){
                fullToken=fullToken+characterToBeChecked;
            }
            //if the current char is from the operators it will be added as separated token like if the current char is  + it will be added to list
            else if(operators.contains(Character.toString(characterToBeChecked))){
                if(!fullToken.isEmpty()) {
                    tokens.add(fullToken);
                    fullToken = "";
                }
                    tokens.add(Character.toString(characterToBeChecked));
                }
   // here to add such like these operations >= ,<= in order to add them as one token I will check the current token and the next char in order to add them in one token
         //   for example if the current token is > then i will check the next char if it is = then i will concate them and add them to the tokens list
            else if(i+1<input.length() && relationalOperators2.contains(String.valueOf(characterToBeChecked) + input.charAt(i + 1))){
                if(fullToken.isEmpty()) {
                    fullToken = fullToken + characterToBeChecked+input.charAt(i+1);
                    tokens.add(fullToken);
                    i=i+1;
                    fullToken = "";
                }else{
                    tokens.add(fullToken);
                    fullToken = "";
                    fullToken = fullToken + characterToBeChecked+input.charAt(i+1);
                    tokens.add(fullToken);
                    i=i+1;
                    fullToken = "";
                }
            }
            //here if the current char is one of the relation operators such as = it will be added to tokens list
            else if( relationalOperators1.contains(Character.toString(characterToBeChecked))){
                if(!fullToken.isEmpty()) {
                    tokens.add(fullToken);
                    fullToken = "";
                }
                tokens.add(Character.toString(characterToBeChecked));

            }
            //if the current char is one of the symbol such as ; or . it will be added to tokens list
            else if( symbols.contains(Character.toString(characterToBeChecked))){
                if(!fullToken.isEmpty()) {
                    tokens.add(fullToken);
                    fullToken = "";
                }
                tokens.add(Character.toString(characterToBeChecked));
            }

        else if (Character.isWhitespace(characterToBeChecked)) {
               if(!fullToken.isEmpty()) {
                  // System.out.println("Fulllll"+fullToken);
                   tokens.add(fullToken);
                   fullToken="";
               }
            }
        else{
                if(!fullToken.isEmpty()) {
                    tokens.add(fullToken);
                    fullToken="";
                }
                tokens.add(Character.toString(characterToBeChecked));

            }
        if(i==input.length()-1 &&!fullToken.isEmpty()){
            tokens.add(fullToken);
        }

        }
   return tokens;
    }

//Reading the file and store it in array of bytes called bytes
    public static String readFile(String filename) {
        try {
            byte[] bytes = Files.readAllBytes(Paths.get( filename));

            return new String(bytes);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}